<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见排序算法总结（javascript实现）</title>
      <link href="/posts/67d771c4/"/>
      <url>/posts/67d771c4/</url>
      
        <content type="html"><![CDATA[<p>学习算法知识，先从基础的排序问题入手。本文分析了常见排序算法的思路并通过实例分步说明，算法流程大都均配合动画演示，最后给出 JavaScript 的实现方法。<br>文章中难免出现某些错误，欢迎指正。</p><br><h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h2><p>冒泡排序是一种简单的排序算法，其得名于较小的元素会经由反复交换逐渐“浮”至数列顶端。</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>从第一个元素开始，比较两相邻元素。若前者大于后者，则两者互换。</li><li>一次外循环结束，末端元素为最大的数，之后不再参与排序。</li><li>对剩余每对相邻元素重复上述步骤，直至再无任何一对数据需比较。<a id="more"></a></li></ol><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><p>以数组 <code>[5, 9, 3, 1, 10, 6]</code> 为例（未发生交换的步骤已省略）：</p><p><img src="https://i.loli.net/2018/06/02/5b12889f0302c.gif" alt="Bubble_Sort.gif"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">第一次循环：</span><br><span class="line">   [<span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>] → </span><br><span class="line">   [<span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>] → </span><br><span class="line">   [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">6</span>] →</span><br><span class="line">   [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">10</span>]  </span><br><span class="line"></span><br><span class="line">第二次循环（除开末端元素 <span class="number">10</span>，对剩余元素排序）：</span><br><span class="line">→ [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">10</span>] → </span><br><span class="line">   [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">10</span>] → </span><br><span class="line">   [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">第三次循环（除开后两个已排序好的元素）：</span><br><span class="line">→ [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>] →</span><br><span class="line">   [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">第四次循环（对前三个元素排序，可注意到数组已排序完成，但程序本身并不知道，因此后续循环将继续进行）：</span><br><span class="line">→ [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">第五次循环（最后一次）</span><br></pre></td></tr></table></figure><h3 id="JS实现"><a href="#JS实现" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> len = arr.length,</span><br><span class="line">       i,</span><br><span class="line">       j,</span><br><span class="line">       temp;</span><br><span class="line">   <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">               temp = arr[j];</span><br><span class="line">               arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">               arr[j + <span class="number">1</span>] = temp</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鸡尾酒排序-Cocktail-Sort"><a href="#鸡尾酒排序-Cocktail-Sort" class="headerlink" title="鸡尾酒排序 (Cocktail Sort)"></a>鸡尾酒排序 (Cocktail Sort)</h2><p>鸡尾酒排序，又称双向冒泡排序，是冒泡排序的轻微变形。不同在于，鸡尾酒排序是从低到高然后从高到低来回排序的，而冒泡排序仅从低到高排序。鸡尾酒排序可能比冒泡排序的效率稍好一点，原因是冒泡排序仅从一个方向进行比对，每次循环只移动一个项目。但在乱数序列状态下，鸡尾酒排序与冒泡排序的效率都很低，优点只有原理简单这一点。</p><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>先对数组从左到右进行冒泡排序（升序），最大的元素移至最右端。</li><li>再对数组从右到左进行冒泡排序（降序），最小的元素移至最左端。</li><li>以此类推，依次改变冒泡的方向，并不断缩小未排序元素的范围，直到最后一个元素结束。</li></ol><h3 id="实例演示-1"><a href="#实例演示-1" class="headerlink" title="实例演示"></a>实例演示</h3><p>仍以数组 <code>[5, 9, 3, 1, 10, 6]</code> 为例：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一次循环：</span><br><span class="line">   [<span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>] → </span><br><span class="line">   [<span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>] → </span><br><span class="line">   [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">6</span>] →</span><br><span class="line">   [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">10</span>] →</span><br><span class="line">   [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>] →</span><br><span class="line">   [<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>] →</span><br><span class="line">   [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>] →</span><br><span class="line"></span><br><span class="line">第二次循环（最后一次）：</span><br><span class="line">→ [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h3 id="JS实现-1"><a href="#JS实现-1" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cocktailSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length,</span><br><span class="line">        left = <span class="number">0</span>,</span><br><span class="line">        right = len - <span class="number">1</span>,</span><br><span class="line">        lastSwappedLeft = left,</span><br><span class="line">        lastSwappedRight = right,</span><br><span class="line">        i,</span><br><span class="line">        j;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 从左到右</span></span><br><span class="line">        lastSwappedRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                lastSwappedRight = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right = lastSwappedRight;</span><br><span class="line">        <span class="comment">// 从右到左</span></span><br><span class="line">        lastSwappedLeft = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = right; left &lt; j; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">                swap(arr, j - <span class="number">1</span>, j)</span><br><span class="line">                lastSwappedLeft = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = lastSwappedLeft;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 (Insertion Sort)"></a>插入排序 (Insertion Sort)</h2><p>插入排序是一种简单直观的排序算法。它的原理是构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。在实现上，插入排序通常采用 <code>in-place</code> 排序，因而在从后向前扫描过程中，需反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>当需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。</p><p>插入排序有一种优化算法，叫 <strong>二分（折半）插入排序(Binary insert sort)</strong> 。其与直接插入排序最大的区别在于查找插入位置时使用二分查找的方式，在速度上有一定提升。这里不详细说明。</p><h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>第一个元素作为起始元素，默认已被排序。</li><li>按顺序取出之后的一个新元素，在已被排序的元素中从后向前扫描，<br>如新元素小于被排序的某元素，则将该被比较的已排序元素移到下一位置。</li><li>对新元素和已排序元素重复上述比较步骤，直至存在某已排序元素小于或等于新元素，然后将新元素插至该已排序元素的位置后。</li><li>重复步骤 <code>2~3</code>。</li></ol><h3 id="实例演示-2"><a href="#实例演示-2" class="headerlink" title="实例演示"></a>实例演示</h3><p>以数组 <code>[5, 9, 3, 1, 10, 6, 7, 2]</code> 为例：</p><p><img src="https://i.loli.net/2018/06/02/5b1288d564ea4.gif" alt="Insertion_Sort.gif"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>]  <span class="number">9</span>  <span class="number">3</span>  <span class="number">1</span>  <span class="number">10</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">2</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>]  <span class="number">3</span>  <span class="number">1</span>  <span class="number">10</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">2</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>]  <span class="number">1</span>  <span class="number">10</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>]  <span class="number">10</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>]  <span class="number">6</span>  <span class="number">7</span>  <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]  <span class="number">7</span>  <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>]  <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h3 id="JS实现-2"><a href="#JS实现-2" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        temp  = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j<span class="number">-1</span>]&gt;temp)&#123;</span><br><span class="line">                arr[j]=arr[j<span class="number">-1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[j]=temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序 (Shell Sort)"></a>希尔排序 (Shell Sort)</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。与插入排序的不同之处在于，它会优先比较距离较远的元素。在初期选用增量较大的间隔，使数据跳跃式接近其位置，然后增量逐渐缩小直至增量为 <code>1</code>。这样移动次数可大大减少，提高排序效率。<br>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态定义。</p><h3 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h3><p>1.取一个正整数 <code>d1(d1 &lt; n)</code>，把全部数据分为 d1 个组，所有距离为 <code>d1</code> 的倍数的数据视为一组，然后在各组内进行插入排序。</p><ol start="2"><li>取正整数 <code>d2(d2 &lt; d1)</code>。</li><li>重复上述分组和排序操作，直到取 <code>di = 1(i &gt;= 1)</code> ，对这个组插入排序。一般选 <code>d1</code> 约为 <code>n/2</code>，<code>d2</code> 为 <code>d1/2</code>， <code>d3</code> 为 <code>d2/2</code>，<code>…</code>， <code>di = 1</code>。</li></ol><h3 id="实例演示-3"><a href="#实例演示-3" class="headerlink" title="实例演示"></a>实例演示</h3><p>以数组 <code>[82, 96, 63, 17, 42, 30, 68, 76, 11]</code> 为例，首先取 <code>d1 = 4</code>，将数组分为 <code>4</code> 组，小组编号<code>01~04</code>。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>  <span class="number">02</span>  <span class="number">03</span>  <span class="number">04</span>  <span class="number">01</span>  <span class="number">02</span>  <span class="number">03</span>  <span class="number">04</span>  <span class="number">01</span></span><br><span class="line"> |   |   |   |   |   |   |   |   |</span><br><span class="line"><span class="number">82</span>  <span class="number">96</span>  <span class="number">63</span>  <span class="number">17</span>  <span class="number">42</span>  <span class="number">30</span>  <span class="number">68</span>  <span class="number">76</span>  <span class="number">11</span></span><br><span class="line"></span><br><span class="line">然后分别对 <span class="number">4</span> 个小组进行插入排序，排序后的结果为：</span><br><span class="line"> |   |   |   |   |   |   |   |   |</span><br><span class="line"><span class="number">11</span>  <span class="number">30</span>  <span class="number">36</span>  <span class="number">17</span>  <span class="number">42</span>  <span class="number">96</span>  <span class="number">68</span>  <span class="number">76</span>  <span class="number">82</span></span><br><span class="line"></span><br><span class="line">取 d2 = <span class="number">2</span>，将数组分为 <span class="number">2</span> 个小组，然后分别对 <span class="number">2</span> 个小组进行插入排序，排序后的结果为：</span><br><span class="line"></span><br><span class="line"><span class="number">01</span>  <span class="number">02</span>  <span class="number">01</span>  <span class="number">02</span>  <span class="number">01</span>  <span class="number">02</span>  <span class="number">01</span>  <span class="number">02</span>  <span class="number">01</span></span><br><span class="line"> |   |   |   |   |   |   |   |   |</span><br><span class="line"><span class="number">11</span>  <span class="number">30</span>  <span class="number">36</span>  <span class="number">17</span>  <span class="number">42</span>  <span class="number">96</span>  <span class="number">68</span>  <span class="number">76</span>  <span class="number">82</span></span><br><span class="line"></span><br><span class="line">最后，取 d3 = <span class="number">1</span>，插入排序后得到最终结果：</span><br><span class="line">[<span class="number">11</span>  <span class="number">17</span>  <span class="number">30</span>  <span class="number">36</span>  <span class="number">42</span>  <span class="number">68</span>  <span class="number">76</span>  <span class="number">82</span>  <span class="number">96</span>]</span><br></pre></td></tr></table></figure><h3 id="JS实现-3"><a href="#JS实现-3" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(gap &lt; len/<span class="number">3</span>) &#123;          <span class="comment">//动态定义间隔序列</span></span><br><span class="line">        gap =gap*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</span><br><span class="line">                arr[j+gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序 (Selection Sort)"></a>选择排序 (Selection Sort)</h2><p>选择排序是一种相当直观的，完全依靠交换去移动元素的排序算法。唯一优点不占用额外内存空间。</p><h3 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>将数组中第一个元素设为初始最小值。</li><li>遍历每个未排序元素，找出剩余序列中元素最小值，与初始最小值比较，若该元素值小于初始最小值，则与初始最小值交换位置并将其设为新最小值；若该元素值大于或等于初始最小值，则位置不移动。</li><li>在剩余未排序元素中重复步骤 <code>2</code>，直至所有元素排序完毕。</li></ol><h3 id="实例演示-4"><a href="#实例演示-4" class="headerlink" title="实例演示"></a>实例演示</h3><p>以数组 <code>[5, 9, 3, 1, 10, 6, 7, 2, 12, 8]</code> 为例：</p><p><img src="https://i.loli.net/2018/06/02/5b12897ac09a7.gif" alt="Selection_Sort.gif"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">首先设 <span class="number">5</span> 为初始最小值，再从数组中找到最小的数 <span class="number">1</span>，与 <span class="number">5</span> 交换位置：</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">8</span>] →</span><br><span class="line">[<span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">在剩余序列中找到最小的数 <span class="number">2</span>，与剩余序列首元素交换位置：</span><br><span class="line">[<span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">8</span>] →</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">继续在剩余序列中找到最小数 <span class="number">3</span>，与剩余序列首元素交换位置（实际上不需要交换，过程省略）：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">8</span>] </span><br><span class="line"></span><br><span class="line">重复上述过程，直至所有元素排序完毕：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">8</span>] →</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">8</span>] →</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">8</span>] →</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">10</span>] →</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">10</span>] →</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure><h3 id="JS实现-4"><a href="#JS实现-4" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = arr.length,</span><br><span class="line">      i,</span><br><span class="line">      j,</span><br><span class="line">      minIndex,</span><br><span class="line">      minValue,</span><br><span class="line">      temp;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    minIndex = i;</span><br><span class="line">    minValue = arr[minIndex];</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++) &#123; <span class="comment">//通过循环选出最小的</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; minValue) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">        minValue = arr[minIndex];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换位置</span></span><br><span class="line">    temp = arr[i];</span><br><span class="line">    arr[i] = minValue;</span><br><span class="line">    arr[minIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 (Merge Sort)"></a>归并排序 (Merge Sort)</h2><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法(Divide and Conquer)的典型应用。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，代价是需要额外的内存空间。</p><p>归并排序每次都在相邻的数据中进行操作，所以其在 <code>O(nlogn)</code> 的几种排序方法（希尔排序，归并排序，快速排序，堆排序）中效率也是比较高的。</p><blockquote><p><strong>分治法的基本思想：</strong><br>将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p></blockquote><p>归并操作(Merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。<br>归并排序有多路归并排序、两路归并排序，可用于内排序，也可用于外排序。这里仅对内排序的两路归并方法进行讨论。</p><h3 id="算法思路-5"><a href="#算法思路-5" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>把原数组分拆为 <code>n</code> 个长度为 <code>1</code> 的子数组。</li><li>将长度为 <code>1</code> 的子数组两两归并为 <code>n/2</code> 个长度为 <code>2</code> 的子数组，并使每个子数组有序。</li><li>重复步骤 <code>2</code> 直至所有子数组归并为长度为 <code>n</code> 的有序数组为止。</li></ol><h3 id="实例演示-5"><a href="#实例演示-5" class="headerlink" title="实例演示"></a>实例演示</h3><p>以数组 <code>[5, 9, 3, 1, 10, 6, 7, 2]</code> 为例：</p><p><img src="https://i.loli.net/2018/06/02/5b1288ee14d03.gif" alt="Merge_Sort.gif"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>] →</span><br><span class="line">[<span class="number">5</span>]   [<span class="number">9</span>]   [<span class="number">3</span>]   [<span class="number">1</span>]   [<span class="number">10</span>]   [<span class="number">6</span>]   [<span class="number">7</span>]   [<span class="number">2</span>] →</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>]   [<span class="number">3</span>, <span class="number">1</span>]   [<span class="number">10</span>, <span class="number">6</span>]   [<span class="number">7</span>, <span class="number">2</span>] →</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>]   [<span class="number">1</span>, <span class="number">3</span>]   [<span class="number">6</span>, <span class="number">10</span>]   [<span class="number">2</span>, <span class="number">7</span>] →</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>]   [<span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">7</span>] →</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>]   [<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>] →</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>] →</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><h3 id="JS实现-5"><a href="#JS实现-5" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr, first, last</span>) </span>&#123;</span><br><span class="line">        first = (first === <span class="literal">undefined</span>) ? <span class="number">0</span> : first</span><br><span class="line">        last = (last === <span class="literal">undefined</span>) ? arr.length - <span class="number">1</span> : last</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor((first + last) / <span class="number">2</span>);</span><br><span class="line">        sort(arr, first, middle);</span><br><span class="line">        sort(arr, middle + <span class="number">1</span>, last);</span><br><span class="line">        <span class="keyword">var</span> f = first,</span><br><span class="line">            m = middle,</span><br><span class="line">            i,</span><br><span class="line">            temp;</span><br><span class="line">        <span class="keyword">while</span> (f &lt;= m &amp;&amp; m + <span class="number">1</span> &lt;= last) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[f] &gt;= arr[m + <span class="number">1</span>]) &#123; <span class="comment">// 这里使用了插入排序的思想</span></span><br><span class="line">                temp = arr[m + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (i = m; i &gt;= f; i--) &#123;</span><br><span class="line">                    arr[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[f] = temp;</span><br><span class="line">                m++</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sort(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h2><p>快速排序与归并排序一样，是分治法的典型应用。本质上，快速排序可看作是在冒泡排序基础上的递归分治法。其基本思想是，通过一次排序将待排数据分隔成独立的两部分，其中一部分数据的关键字均比另一部分的关键字小，则可分别对这两部分数据继续进行排序，以达到整个序列有序。</p><p>它是处理大数据最快的排序算法之一。虽然快速排序 Worst Case 的时间复杂度达到了 <code>O(n²)</code>，比如说顺序数列的快排。但它的期望时间是 <code>O(nlogn)</code>，且<code>O(nlogn)</code> 记号中隐含的常数因子很小，比复杂度稳定等于 <code>O(nlogn)</code> 的归并排序要小很多。所以对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p><h3 id="算法思路-6"><a href="#算法思路-6" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>从数组中选择一个元素作为”基准”（pivot）。</li><li>所有小于 <code>pivot</code> 的元素，都移其左侧至；所有大于 <code>pivot</code> 的元素，都移到其右侧，此操作称为分区 (partition)。一次分区操作结束后，<code>pivot</code> 所处的位置就是最终排序后它的位置。</li><li>对 <code>pivot</code> 左右两侧子集，不断重复步骤 <code>1~2</code>，直至所有子集只剩下一个元素为止。</li></ol><h3 id="实例演示-6"><a href="#实例演示-6" class="headerlink" title="实例演示"></a>实例演示</h3><p>以数组 <code>[5, 2, 7, 6, 10, 3, 8, 9]</code> 为例：</p><p><img src="https://i.loli.net/2018/06/02/5b1289368e09a.gif" alt="Quick_Sort.gif"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">首先选定一个基准元素，这里我们选取 <span class="number">6</span> 为pivot（可任意选择）：</span><br><span class="line"></span><br><span class="line">              pivot</span><br><span class="line">                |</span><br><span class="line">    <span class="number">5</span>   <span class="number">2</span>   <span class="number">7</span>   <span class="number">6</span>   <span class="number">10</span>   <span class="number">3</span>   <span class="number">8</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将基准元素与数组最后一个元素交换位置，若选择末端元素为基准元素则可省略该步：</span><br><span class="line"></span><br><span class="line">                               pivot</span><br><span class="line">                                 |</span><br><span class="line">    <span class="number">5</span>   <span class="number">2</span>   <span class="number">7</span>   <span class="number">9</span>   <span class="number">10</span>   <span class="number">3</span>   <span class="number">8</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从左至右遍历（除了最后的pivot），所有小于 <span class="number">6</span> 的元素与 storeIndex 所指向的元素交换位置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i == <span class="number">0</span>，storeIndex == <span class="number">0</span>，找到小于pivot的元素 <span class="number">5</span>，与 storeIndex 所在位置的元素交换位置，这里为 <span class="number">5</span> 本身：</span><br><span class="line"></span><br><span class="line">                               pivot</span><br><span class="line">                                 |</span><br><span class="line">    <span class="number">5</span>   <span class="number">2</span>   <span class="number">7</span>   <span class="number">9</span>   <span class="number">10</span>   <span class="number">3</span>   <span class="number">8</span>   <span class="number">6</span></span><br><span class="line">    |</span><br><span class="line">storeIndex</span><br><span class="line"></span><br><span class="line">一次交换后 storeIndex + <span class="number">1</span>，storeIndex == <span class="number">1</span>；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i == <span class="number">1</span>，storeIndex == <span class="number">1</span>，找到小于pivot的元素 <span class="number">2</span>，与 storeIndex 所在位置的元素交换位置，这里是 <span class="number">2</span> 本身：</span><br><span class="line"></span><br><span class="line">                               pivot</span><br><span class="line">                                 |</span><br><span class="line">    <span class="number">5</span>   <span class="number">2</span>   <span class="number">7</span>   <span class="number">9</span>   <span class="number">10</span>   <span class="number">3</span>   <span class="number">8</span>   <span class="number">6</span></span><br><span class="line">        |</span><br><span class="line">    storeIndex</span><br><span class="line"></span><br><span class="line">一次交换后 storeIndex == <span class="number">2</span>；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i == <span class="number">5</span>，storeIndex == <span class="number">2</span>，找到小于pivot的元素 <span class="number">3</span>，与 storeIndex 所在位置的元素交换位置：</span><br><span class="line"></span><br><span class="line">                               pivot</span><br><span class="line">                                 |</span><br><span class="line">    <span class="number">5</span>   <span class="number">2</span>   <span class="number">7</span>   <span class="number">9</span>   <span class="number">10</span>   <span class="number">3</span>   <span class="number">8</span>   <span class="number">6</span>   →   </span><br><span class="line">            |            |</span><br><span class="line">        storeIndex       i</span><br><span class="line"></span><br><span class="line">                               pivot</span><br><span class="line">                                 |</span><br><span class="line">    <span class="number">5</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">9</span>   <span class="number">10</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">6</span>      </span><br><span class="line">                |</span><br><span class="line">            storeIndex</span><br><span class="line"></span><br><span class="line">一次交换后 storeIndex == <span class="number">3</span>；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">循环结束，交换 pivot 与 storeIndex 指向元素的位置：</span><br><span class="line"></span><br><span class="line">              pivot</span><br><span class="line">                |</span><br><span class="line">    <span class="number">5</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">6</span>   <span class="number">10</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>      </span><br><span class="line">                |</span><br><span class="line">            storeIndex</span><br></pre></td></tr></table></figure><p>如此完成一次分区操作，此时 <code>storeIndex</code> 对应位置就是 <code>pivot</code> 的最终位置，接下来对 <code>pivot</code> 左右两侧子集执行相同操作至单元素子集即可。</p><h3 id="JS实现-6"><a href="#JS实现-6" class="headerlink" title="JS实现"></a>JS实现</h3><p>这里推荐原地(in-place)分区版本的快速排序。关于原地算法可参考<a href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="external nofollow noopener noreferrer" target="_blank">In-place algorithm</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分区</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 开始时并不知道 pivot 的最终存放位置，故可先将 pivot 交换到后面去，</span></span><br><span class="line"><span class="comment">         * 这里直接定义最右边的元素为基准</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> pivot = arr[right];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存放小于 pivot 的元素时，是紧挨着上一元素的，否则空隙里存放的可能是大于pivot的元素，</span></span><br><span class="line"><span class="comment">         * 故声明变量 storeIndex，并初始化为left来依次紧挨着存放小于 pivot 的元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> storeIndex = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 遍历数组，找到小于 pivot 的元素，（大于 pivot 的元素会跳过）</span></span><br><span class="line"><span class="comment">                 * 将循环 i 次时得到的元素，通过 swap 交换放到 storeIndex 处，</span></span><br><span class="line"><span class="comment">                 * 并对 storeIndex 递增 1，表示下一个可能要交换的位置</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                swap(arr, storeIndex, i);</span><br><span class="line">                storeIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后： 将 pivot 交换到 storeIndex 处，基准元素放置到最终正确位置上</span></span><br><span class="line">        swap(arr, right, storeIndex);</span><br><span class="line">        <span class="keyword">return</span> storeIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">var</span> storeIndex = partition(arr, left, right);</span><br><span class="line">        sort(arr, left, storeIndex - <span class="number">1</span>);</span><br><span class="line">        sort(arr, storeIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序 (Heap Sort)"></a>堆排序 (Heap Sort)</h2><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。</p><h3 id="算法思路及演示"><a href="#算法思路及演示" class="headerlink" title="算法思路及演示"></a>算法思路及演示</h3><p>在给出堆排序算法之前，首先介绍几个基本概念：</p><ol><li><p>二叉树</p><p>在计算机科学中，二叉树是每个节点至多有两个子树的树结构，常被用于实现二叉查找树和二叉堆。二叉树子树被称作“左子树”(left subtree)和“右子树”(right subtree)，次序不可颠倒。</p><p>二叉树分为完全二叉树(complete binary tree)和满二叉树(full binary tree)。</p><ul><li><p>完全二叉树：深度为 <code>k</code>，有 <code>n</code> 个节点的二叉树，当且仅当其每一个节点都与深度为 <code>k</code> 的满二叉树中序号为 <code>1</code> 至 <code>n</code> 的节点对应时，称之为完全二叉树。</p><p>深度为 <code>3</code> 的完全二叉树：<br><img src="https://i.loli.net/2018/06/02/5b128ca63b62f.png" alt="complete_binary_tree.png"></p></li><li><p>满二叉树：一棵深度为 <code>k</code>，且有 <code>2k - 1</code> 个节点称之为满二叉树。</p><p>深度为 <code>3</code> 的满二叉树：<br><img src="https://i.loli.net/2018/06/02/5b128c9010197.png" alt="full_binary_tree.png"></p></li></ul></li><li><p>堆</p><p>堆（二叉堆）可视为一棵完全二叉树，完全二叉树除最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。</p><p>下图是一个堆和数组的相互关系：<br><img src="https://i.loli.net/2018/06/02/5b128c17be234.png" alt="heap-and-array.png"></p><p>对于给定的某结点的下标 <code>i</code>，容易计算出该结点的父结点、子结点的下标：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Parent</span><span class="params">(i)</span></span> = floor(<span class="selector-tag">i</span> / <span class="number">2</span>)   <span class="comment">// i 的父节点下标</span></span><br><span class="line"><span class="function"><span class="title">Left</span><span class="params">(i)</span></span> = <span class="number">2</span>i   <span class="comment">// i 的左子节点下标</span></span><br><span class="line"><span class="function"><span class="title">Right</span><span class="params">(i)</span></span> = <span class="number">2</span>i + <span class="number">1</span>   <span class="comment">// i 的右子节点下标</span></span><br></pre></td></tr></table></figure><p>二叉堆一般分为两种：最大堆和最小堆。</p><p>最大堆：</p><ul><li><p>最大堆中的最大元素值出现在根结点（堆顶）</p></li><li><p>堆中每个父节点的元素值都大于等于其孩子结点（如果存在）</p><p><img src="https://i.loli.net/2018/06/02/5b128cc148a54.png" alt="max-heap.png"></p><p>最小堆：</p></li><li><p>最小堆中的最小元素值出现在根结点（堆顶）</p></li><li><p>堆中每个父节点的元素值都小于等于其孩子结点（如果存在）</p><p><img src="https://i.loli.net/2018/06/02/5b128af9118ec.png" alt="min-heap.png"></p></li></ul></li></ol><br><ol start="3"><li><p>堆排序原理</p><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆调整为最大堆，再次将堆顶的最大数取出，此过程持续至剩余数只有一个时结束。操作中有如下定义：</p><ul><li><p>最大堆调整 (Max-Heapify)：将堆的末端子节点作调整，使得子节点永远小于父节点</p></li><li><p>创建最大堆 (Build-Max-Heap)：将堆所有数据重新排序，使其成为最大堆</p></li><li><p>堆排序 (Heap-Sort)：移除位在第一个数据的根节点，并做最大堆调整的递归运算</p><p>继续进行下面的讨论前，需要注意的一个问题是，数组都是 <code>Zero-Based</code>，这就意味着堆数据结构模型要发生改变:</p><p><img src="https://i.loli.net/2018/06/02/5b128c4640519.png" alt="heap-and-array-zero-based.png"></p><p>相应的计算公式也要作出相应调整：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Parent</span><span class="params">(i)</span></span> = floor((<span class="selector-tag">i</span> - <span class="number">1</span>) / <span class="number">2</span>)     <span class="comment">// i 的父节点下标</span></span><br><span class="line"><span class="function"><span class="title">Left</span><span class="params">(i)</span></span> = <span class="number">2</span>i + <span class="number">1</span>     <span class="comment">// i 的左子节点下标</span></span><br><span class="line"><span class="function"><span class="title">Right</span><span class="params">(i)</span></span> = <span class="number">2</span>(<span class="selector-tag">i</span> + <span class="number">1</span>)     <span class="comment">// i 的右子节点下标</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>最大堆调整 (MAX‐HEAPIFY)</p><p>保持最大堆性质，是创建最大堆的核心子程序，作用过程如图：</p><p><img src="https://i.loli.net/2018/06/02/5b128cfdc7641.png" alt="MAX_HEAPIFY-_Procedure.png"></p><p>由于一次调整后，堆仍然违反堆性质，这里用迭代的方法使得整个堆都满足堆性质：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> - 从 index 开始检查并保持最大堆性质</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> - @arr</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> - @index 检查的起始下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> - @heapSize 堆大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">arr, index, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iMax, iLeft, iRight;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    iMax = index;</span><br><span class="line">    iLeft = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    iRight = <span class="number">2</span> * (index + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; arr[index] &lt; arr[iLeft]) &#123;</span><br><span class="line">      iMax = iLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; arr[iMax] &lt; arr[iRight]) &#123;</span><br><span class="line">      iMax = iRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iMax != index) &#123;</span><br><span class="line">      swap(arr, iMax, index);</span><br><span class="line">      index = iMax;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建最大堆 (Build-Max-Heap)</p><p>作用是将一个数组改造成一个最大堆，接受数组和堆大小两个参数，<code>Build-Max-Heap</code> 将自下而上的调用 <code>Max-Heapify</code> 来改造数组，建立最大堆。因为 <code>Max-Heapify</code> 能够保证下标为 <code>i</code> 的结点之后的结点都满足最大堆的性质，所以自下而上的调用 <code>Max-Heapify</code> 能够在改造过程中保持这一性质。如果最大堆的数量元素是 <code>n</code>，那么 <code>Build-Max-Heap</code> 从 <code>Parent(n)</code> 开始，往上依次调用 <code>Max-Heapify</code>。流程如下：</p><p><img src="https://i.loli.net/2018/06/02/5b128d2496ceb.png" alt="building-a-heap.png"></p><p>相关 JavaScript 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">array, heapSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i,</span><br><span class="line">      iParent = <span class="built_in">Math</span>.floor((heapSize - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">for</span> (i = iParent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    maxHeapify(array, i, heapSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>堆排序 (Heap-Sort)</p><p>为堆排序的接口算法，<code>Heap-Sort</code> 先调用 <code>Build-Max-Heap</code> 将数组改造为最大堆，然后将堆顶和堆底元素交换，之后将底部上升，最后重新调用 <code>Max-Heapify</code> 保持最大堆性质。由于堆顶元素必然是堆中最大的元素，所以一次操作之后，堆中存在的最大元素被分离出堆，重复 <code>n - 1</code>次之后，数组排列完毕。整个流程如下：</p><p><img src="https://i.loli.net/2018/06/02/5b128c62450e6.png" alt="Heap_Sort.png"></p><p>相关 JavaScript 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array, heapSize</span>) </span>&#123;</span><br><span class="line">  buildMaxHeap(array, heapSize);</span><br><span class="line">  <span class="keyword">for</span> (int i = heapSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(array, <span class="number">0</span>, i);</span><br><span class="line">    maxHeapify(array, <span class="number">0</span>, i);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="JS实现-7"><a href="#JS实现-7" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">arr, index, heapSize</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iMax,</span><br><span class="line">      iLeft,</span><br><span class="line">      iRight;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      iMax = index;</span><br><span class="line">      iLeft = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">      iRight = <span class="number">2</span> * (index + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (iLeft &lt; heapSize &amp;&amp; arr[index] &lt; arr[iLeft]) &#123;</span><br><span class="line">        iMax = iLeft;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (iRight &lt; heapSize &amp;&amp; arr[iMax] &lt; arr[iRight]) &#123;</span><br><span class="line">        iMax = iRight;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (iMax != index) &#123;</span><br><span class="line">        swap(arr, iMax, index);</span><br><span class="line">        index = iMax;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i,</span><br><span class="line">      iParent = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = iParent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      maxHeapify(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      swap(arr, <span class="number">0</span>, i);</span><br><span class="line">      maxHeapify(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sort(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序-Counting-sort"><a href="#计数排序-Counting-sort" class="headerlink" title="计数排序 (Counting sort)"></a>计数排序 (Counting sort)</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外的数组空间中。</p><p>计数排序使用一个额外的数组 <code>C</code>，其中第 <code>i</code> 个元素是待排序数组A中值等于 <code>i</code> 的元素的个数，然后根据数组 <code>C</code> 来将 <code>A</code> 中的元素排到正确的位置。</p><p>计数排序是型非比较排序，其速度快于任何比较排序算法。</p><p>作为一种线性时间复杂度的排序，它只能对有确定范围的整数进行排序。当输入的元素是 <code>n</code> 个 <code>0</code> 到 <code>k</code> 之间的整数时，它的运行时间是 <code>O(n + k)</code>。</p><p>由于用于计数的数组 <code>C</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 <code>1</code>），这使得计数排序处理数据范围很大的数组需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><h3 id="算法思路-7"><a href="#算法思路-7" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>找出待排序数组中最大及最小元素。</li><li>统计数组中每个值为 <code>i</code> 的元素出现的次数，存入数组 <code>C</code> 的第 <code>i</code> 项。</li><li>对所有的计数累加（从 <code>C</code> 中的第一个元素开始，每一项和前一项相加）。</li><li>反向填充目标数组：将每个元素 <code>i</code> 放在新数组的第 <code>C(i)</code> 项，每放一个元素就将 <code>C(i)</code> 减去 <code>1</code>。</li></ol><h3 id="实例演示-7"><a href="#实例演示-7" class="headerlink" title="实例演示"></a>实例演示</h3><p><img src="https://i.loli.net/2018/06/02/5b1288b82cb7d.gif" alt="Counting_sort.gif"></p><h3 id="JS实现-8"><a href="#JS实现-8" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">iArr, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = iArr.length;</span><br><span class="line">    <span class="keyword">var</span> oArr = [];</span><br><span class="line">    <span class="comment">// 创建长度max的数组，填充0</span></span><br><span class="line">    <span class="keyword">var</span> C = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= max; i++)&#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历输入数组，填充C</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        C[iArr[j]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历C，输出数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt;= max; k++)&#123;</span><br><span class="line">        <span class="comment">// 按顺序将值推入输出数组，并将对应标志位减1</span></span><br><span class="line">        <span class="keyword">while</span>(C[k]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            oArr.push(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序 (Bucket Sort)"></a>桶排序 (Bucket Sort)</h2><p>桶排序原理是将数组分入有限数量的桶里，然后再对每个桶分别排序（可能以递归方式继续使用桶排序或其它算法），最后将各个桶中的数据有序地合并起来。</p><p>桶排序在大多数情况下是常见排序里最快的一种，比快排还要快，缺点是极耗空间，基本上是最耗空间的一种排序算法，而且只能在某些情形下使用。</p><p>为使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量。</li><li>使用的映射函数能够将输入的 <code>N</code> 个数据均匀分配到 <code>K</code> 个桶中，同时对于桶中元素的排序，比较排序算法的选择对于性能的影响至关重要。</li></ol><p>Best Cases：当输入的数据可均匀分配到每一个桶中</p><p>Worst Cases：当输入的数据被分配至同一个桶中</p><p><a href="http://www.cs.usfca.edu/~galles/visualization/BucketSort.html" rel="external nofollow noopener noreferrer" target="_blank">Data Structure Visualizations</a> 提供了一个桶排序的分步动画演示。</p><h3 id="算法思路-8"><a href="#算法思路-8" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>假设待排序的一组数统一地分布在一个范围，并将这一范围划分为几个子范围，也就是桶。</li><li>将待排序的一组数，分档归入这些子桶，并对桶中数据进行排序。</li><li>将各个桶中的数据有序合并。</li></ol><h3 id="实例演示-8"><a href="#实例演示-8" class="headerlink" title="实例演示"></a>实例演示</h3><p>设有数组<code>[23, 28, 3, 46, 12, 35, 17, 40]</code>，则数组最大值为 <code>46</code>，设置 <code>5</code> 个桶，每个桶可存放数的范围为：<code>0~9</code>、<code>10~19</code>、<code>20~29</code>、<code>30~39</code>、<code>40~49</code>，分别将数据放入各自所属的桶，然后对每个桶里的数排序，或在将数放入桶的同时用插入算法进行排序。最后，将各个桶中的数据有序地合并起来。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">3</span>    <span class="number">12</span>,<span class="number">17</span>   <span class="number">23</span>,<span class="number">28</span>    <span class="number">35</span>     <span class="number">46</span>,<span class="number">40</span></span><br><span class="line"> |      |       |       |       |     →</span><br><span class="line"><span class="number">0</span>~<span class="number">9</span>   <span class="number">10</span>~<span class="number">19</span>   <span class="number">20</span>~<span class="number">29</span>   <span class="number">30</span>~<span class="number">39</span>   <span class="number">40</span>~<span class="number">49</span></span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">28</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">46</span>]</span><br></pre></td></tr></table></figure><h3 id="JS实现-9"><a href="#JS实现-9" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @arr 将要排序的数组</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @step 划分桶的步长，比如 step = 5，表示每个桶存放的数字的范围是 5，像 -4&lt;sub&gt;1、0&lt;/sub&gt;5、6~11</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">arr, step</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [],</span><br><span class="line">        bucket = [],</span><br><span class="line">        bucketCount,</span><br><span class="line">        l = arr.length,</span><br><span class="line">        i,</span><br><span class="line">        j,</span><br><span class="line">        k,</span><br><span class="line">        s,</span><br><span class="line">        max = arr[<span class="number">0</span>],</span><br><span class="line">        min = arr[<span class="number">0</span>],</span><br><span class="line">        temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    min = min - <span class="number">1</span>;</span><br><span class="line">    bucketCount = <span class="built_in">Math</span>.ceil((max - min) / step); <span class="comment">// 需要桶的数量</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; bucketCount; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; (min + step * j) &amp;&amp; temp &lt;= (min + step * (j + <span class="number">1</span>))) &#123; <span class="comment">// 判断放入哪个桶</span></span><br><span class="line">                <span class="keyword">if</span> (!bucket[j]) &#123;</span><br><span class="line">                    bucket[j] = [];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通过插入排序将数字插入到桶中的合适位置</span></span><br><span class="line">                s = bucket[j].length;</span><br><span class="line">                <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (k = s - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (bucket[j][k] &gt; temp) &#123;</span><br><span class="line">                            bucket[j][k + <span class="number">1</span>] = bucket[j][k];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    bucket[j][k + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bucket[j].push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123; <span class="comment">// 循环取出桶中数据</span></span><br><span class="line">        <span class="keyword">if</span> (bucket[i]) &#123;</span><br><span class="line">            k = bucket[i].length;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                result.push(bucket[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序 (Radix Sort)"></a>基数排序 (Radix Sort)</h2><p>基数排序是一种非比较型的整数排序算法，其原理是将整数按位数切割后依次比较。<br>该排序会使用到桶(Bucket)，顾名思义，通过将要比较的位，把要排序的元素分配至 <code>0~9</code> 个桶中，以达到排序的作用。<br>在某些时候，基数排序法的效率高于其它比较型排序法。</p><h3 id="算法思路-9"><a href="#算法思路-9" class="headerlink" title="算法思路"></a>算法思路</h3><ol><li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li><li>从最低位开始，依次进行排序至最高位排序完成。</li></ol><h3 id="实例演示-9"><a href="#实例演示-9" class="headerlink" title="实例演示"></a>实例演示</h3><p>基数排序的方式可采用 <code>LSD (Least sgnificant digital)</code> 或 <code>MSD (Most sgnificant digital)</code>，<code>LSD</code> 的排序方式从键值的最右侧开始，而 <code>MSD</code> 则相反，从键值左侧开始。</p><p>以 <code>LSD</code> 为例，考虑数组 <code>[36, 9, 10, 25, 1, 49, 63, 16, 81, 32, 24, 7, 18, 82]</code>：</p><p><img src="https://i.loli.net/2018/06/02/5b12895329f10.gif" alt="Radix_Sort.gif"></p><p>首先根据个位的值 <code>=</code> 桶编号的方式，将所有元素依次分配至编号 <code>0</code> 到 <code>9</code> 的桶中：</p><table><thead><tr><th align="center">编号</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">10</td><td align="center">1</td><td align="center">32</td><td align="center">63</td><td align="center">24</td><td align="center">25</td><td align="center">36</td><td align="center">7</td><td align="center">18</td><td align="center">9</td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">81</td><td align="center">82</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">16</td><td align="center"></td><td align="center"></td><td align="center">49</td></tr></tbody></table><p>然后，将这些数字按照桶以及桶内部的排序连接起来：<br>[10, 1, 81, 32, 82, 63, 24, 25, 36, 16, 7, 18, 9, 49]</p><p>接着按照十位的数值，分别对号入座：</p><table><thead><tr><th align="center">编号</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">10</td><td align="center">24</td><td align="center">32</td><td align="center">49</td><td align="center"></td><td align="center">63</td><td align="center"></td><td align="center">81</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center">7</td><td align="center">16</td><td align="center">25</td><td align="center">36</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">82</td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">9</td><td align="center">18</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>最后按照次序重现连接，完成排序：<br><code>[1, 7, 9, 10, 16, 18, 24, 25, 32, 36, 49, 63, 81, 82]</code></p><h3 id="JS实现-10"><a href="#JS实现-10" class="headerlink" title="JS实现"></a>JS实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bucket = [],</span><br><span class="line">        len = arr.length,</span><br><span class="line">        loop,</span><br><span class="line">        str,</span><br><span class="line">        i,</span><br><span class="line">        j,</span><br><span class="line">        k,</span><br><span class="line">        t,</span><br><span class="line">        max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    loop = (max + <span class="string">''</span>).length;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        bucket[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">            str = arr[j] + <span class="string">''</span>;</span><br><span class="line">            <span class="keyword">if</span> (str.length &gt;= i + <span class="number">1</span>) &#123;</span><br><span class="line">                k = <span class="built_in">parseInt</span>(str[str.length - i - <span class="number">1</span>]);</span><br><span class="line">                bucket[k].push(arr[j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 高位为 0</span></span><br><span class="line">                bucket[<span class="number">0</span>].push(arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr.splice(<span class="number">0</span>, l);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            t = bucket[j].length;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; t; k++) &#123;</span><br><span class="line">                arr.push(bucket[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            bucket[j] = [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各排序算法特点小结"><a href="#各排序算法特点小结" class="headerlink" title="各排序算法特点小结"></a>各排序算法特点小结</h2><table><thead><tr><th align="center">算法</th><th align="center">平均时间复杂度</th><th align="center">最优时间复杂度</th><th align="center">最差时间复杂度</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">O(n²)</td><td align="center">O(n)</td><td align="center">O(n²)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">鸡尾酒排序</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">选择排序</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(n²)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">插入排序</td><td align="center">O(n²)</td><td align="center">O(n)</td><td align="center">O(n²)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(nlogn)</td><td align="center">O(nlog²n)</td><td align="center">O(n²)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(nlogn)</td><td align="center">O(n)</td><td align="center">O(nlogn)</td><td align="center">O(n)</td><td align="center">稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n²)</td><td align="center">最优O(n) 最差O(logn)</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">计数排序</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">稳定</td></tr><tr><td align="center">桶排序</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(n²)</td><td align="center">O(n*k)</td><td align="center">稳定</td></tr><tr><td align="center">基数排序</td><td align="center">O(n*k)</td><td align="center">O(n*k)</td><td align="center">O(n*k)</td><td align="center">O(n+k)</td><td align="center">稳定</td></tr></tbody></table><ul><li><em>n: 数据规模</em></li><li><em>k: 桶的个数</em></li></ul><h2 id="Bonus：Javascript-随机数组"><a href="#Bonus：Javascript-随机数组" class="headerlink" title="Bonus：Javascript 随机数组"></a>Bonus：Javascript 随机数组</h2><p>在学习排序算法的时候，经常要用到随机数组，于是就写了一个生成随机数组的方法。</p><p>原理是先从所有元素中随机选取一个与第一个元素进行交换，然后从第二个开始选择一个元素与第二个交换，直到最后一个元素。这样能确保每个元素在每个位置的概率都是 <code>1/n</code>。</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 生成从 1 到 length 之间的随机数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @length 随机数组的长度，如果未传递该参数，那么 length 为默认值 9</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomarr</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i,</span><br><span class="line">        index,</span><br><span class="line">        temp,</span><br><span class="line">        arr = [length];</span><br><span class="line">    length = <span class="keyword">typeof</span>(length) === <span class="string">'undefined'</span> ? <span class="number">9</span> : length;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++) &#123;</span><br><span class="line">        arr[i - <span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打乱数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++) &#123;</span><br><span class="line">        <span class="comment">// 产生从 i 到 length 之间的随机数</span></span><br><span class="line">        index = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (length - i)) + i;</span><br><span class="line">        <span class="keyword">if</span> (index != i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[index];</span><br><span class="line">            arr[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>参考资料：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" rel="external nofollow noopener noreferrer" target="_blank">排序算法-维基百科</a></li><li><a href="http://www.jianshu.com/p/1b4068ccd505" rel="external nofollow noopener noreferrer" target="_blank">JS家的排序算法</a></li><li><a href="https://visualgo.net/en/sorting" rel="external nofollow noopener noreferrer" target="_blank">排序算法可视化教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex 布局速记</title>
      <link href="/posts/7b915b90/"/>
      <url>/posts/7b915b90/</url>
      
        <content type="html"><![CDATA[<p>flex 弹性布局使得项目能够弹性地改变其宽高，自由填充容器剩余空间或压缩以适应容器主轴空间，同时还可方便地调节项目方向和顺序。flex 布局常用于项目宽高需要自适应或成比例的场景。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="https://i.loli.net/2018/05/19/5aff0818e19da.png" alt="基本概念"></p><a id="more"></a><ol><li><p>如图所示，在弹性盒模型里，有容器和项目之分，容器可统一设置子项目的排列方式，子项目也可以单独设置自身的排列方式，两者同时设置时，以项目的设置为准。</p></li><li><p>容器中存在两轴，主轴 <code>main axis</code> 和交叉轴 <code>cross axis</code> ，主轴默认水平方向，交叉轴默认垂直方向。可通过修改容器 <code>flex-direction</code> 的属性值设置主轴为垂直方向，交叉轴为水平方向。</p></li><li><p>主轴起始位置为 <code>main start</code>，末尾位置为 <code>main end</code>；交叉轴起始位置为 <code>cross start</code>，末尾位置为 <code>cross end</code>。</p></li><li><p>容器中的项目 (flex item) 占据的主轴空间为 <code>main size</code>, 占据的交叉轴空间为 <code>cross size</code>。默认情况下，<code>main size</code> 为项目宽度，<code>cross size</code> 为项目高度；主轴垂直方向时，两者互换。</p></li><li><p>flex 布局定义了新的格式化上下文 FFC (flex formatting context)，类似 BFC。例如不会被浮动的元素遮盖，垂直外边距不会坍塌等。</p></li><li><p>项目尺寸 (item-size) 为主轴方向上项目的 <code>content + padding + border + margin</code></p><!-- more --></li></ol><h2 id="指定容器"><a href="#指定容器" class="headerlink" title="指定容器"></a>指定容器</h2><p>实现 flex 布局首先需指定一个容器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex | inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，元素将升级为弹性盒，前者为块级盒，后者为行内盒。</p><p>元素采用 flex 布局后, 子元素的 <code>float</code>、<code>clear</code>、<code>vertical-align</code>、<code>::first-line和::first-letter</code> 以及多栏布局模块的 <code>column-*</code> 属性都将失效。</p><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><p>容器可设置以下 6 个属性：</p><ul><li><code>flex-direction</code> 指定主轴的方向</li></ul><table><thead><tr><th align="center">flex-direction</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">row（默认）</td><td align="center">主轴水平方向，子项目从左至右 →</td></tr><tr><td align="center">row-reverse</td><td align="center">主轴水平方向，子项目从右至左 ←</td></tr><tr><td align="center">column</td><td align="center">主轴垂直方向，子项目从上至下 ↓</td></tr><tr><td align="center">column-reverse</td><td align="center">主轴垂直方向，子项目从下至上 ↑</td></tr></tbody></table><ul><li><code>flex-wrap</code> 指定如何换行<br>默认情况下，项目都排在主轴线上，使用 <code>flex-wrap</code> 实现项目换行。</li></ul><table><thead><tr><th align="center">flex-wrap</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">nowrap（默认）</td><td align="center">不换行，即当主轴尺寸固定时而当空间不足时，项目尺寸会随之调整</td></tr><tr><td align="center">wrap</td><td align="center">主轴上项目总尺寸超出容器时换行，第一行在上方</td></tr><tr><td align="center">wrap-reverse</td><td align="center">换行，第一行在下方</td></tr></tbody></table><ul><li><code>flex-flow</code> 前面两个属性的简写形式，默认值为 <code>row nowrap</code></li></ul><ul><li><code>justify-content</code> 指定项目在主轴上的对齐方式</li></ul><table><thead><tr><th align="center">justify-content</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">flex-start（默认）</td><td align="center">起始位置与主轴起点对齐</td></tr><tr><td align="center">flex-end</td><td align="center">末尾位置与主轴终点对齐</td></tr><tr><td align="center">center</td><td align="center">居中</td></tr><tr><td align="center">space-between</td><td align="center">两端对齐，项目之间的间隔相等</td></tr><tr><td align="center">space-around</td><td align="center">各项目间隔相等，且该距离为最左、右侧项目与容器边缘间隔的 2 倍</td></tr></tbody></table><ul><li><code>align-items</code> 指定项目在交叉轴上的对齐方式</li></ul><table><thead><tr><th align="center">align-items</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">stretch（默认）</td><td align="center">未设置高度或者设为 auto，将占满容器高度</td></tr><tr><td align="center">flex-start</td><td align="center">起始位置与交叉轴起点对齐</td></tr><tr><td align="center">flex-end</td><td align="center">末尾位置与交叉轴终点对齐</td></tr><tr><td align="center">center</td><td align="center">基于交叉轴的中点对齐</td></tr><tr><td align="center">baseline</td><td align="center">基于首行文字的基线对齐</td></tr></tbody></table><ul><li><code>align-content</code> 指定多根轴线的对齐方式，即当 <code>flex-wrap</code> 设置为 <code>wrap</code> 时，容器可能会出现多条轴线，此时需要设置该属性。若项目只有一根轴线，则该属性不起作用</li></ul><table><thead><tr><th align="center">align-content</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">stretch（默认）</td><td align="center">多根主轴上的项目充满交叉轴，适用于项目未设置高度</td></tr><tr><td align="center">flex-start</td><td align="center">项目起始位置均与交叉轴起点对齐</td></tr><tr><td align="center">flex-end</td><td align="center">项目末尾位置均与交叉轴终点对齐</td></tr><tr><td align="center">center</td><td align="center">在交叉轴方向居中于容器</td></tr><tr><td align="center">space-between</td><td align="center">与交叉轴两端对齐, 间隔全部相等</td></tr><tr><td align="center">space-around</td><td align="center">各主轴项目间距相等，且该距离为顶部、底部主轴项目与容器边缘间隔的 2 倍</td></tr></tbody></table><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><p>子项目可设置以下 6 个属性：</p><ul><li><p><code>order</code></p><p>指定项目的排列顺序，覆盖 HTML 结构，数值越小，顺序越靠前，可为负值，默认为 0。</p></li><li><p><code>align-self</code></p><p>允许单个项目有与其它项目不同的对齐方式，覆盖容器 <code>align-items</code> 定义的值。该属性共有 6 种值，与 <code>align-items</code> 保持一致，默认为 auto。</p></li><li><p><code>flex-basis</code></p><p>指定项目占据的主轴空间，浏览器会根据该属性计算主轴是否有剩余空间。一般情况下，优先度高于 <code>width</code> 或 <code>height</code>，默认值为 <code>auto</code>，即取项目明确设定的宽高，若宽高未明确设置，则取值依据项目实际内容决定。</p><p><strong>当设定 <code>flex-basis</code> 值为 0% 时，项目的基准空间为 0。</strong></p><p>相关计算的详细规则，请查看【flex-item-size 计算的相关扩展】 一节。</p></li><li><p><code>flex-grow</code></p><p>指定项目的放大比例，值可取任何正整数，默认为 <code>0</code>，即存在剩余空间也不放大。假设各项目的放大比例数值之和为 <code>n</code>， 则容器剩余空间将分为 <code>n</code> 份, 各项目分配到 <code>x/n</code> 份（变量 <code>x</code> 为某项目的放大比例）。</p></li><li><p><code>flex-shrink</code></p><p>指定项目的坍缩比例，当容器主轴剩余空间不够，且未设置 <code>flex-wrap：wrap | wrap-reverse</code> 时，<code>flex-shrink</code> 生效。默认为 1，表示可坍缩；设置为 0 时，即便空间不足项目也不坍缩。取值为非负数，负值无效。</p><p>在计算元素坍缩的实际数值时，需加权项目原本宽高，以图例说明：</p><p><img src="https://i.loli.net/2018/06/02/5b129688e69ed.png" alt="flex-shrink"></p></li><li><p><code>flex</code></p><p><code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code> 三个属性的简写组合，<strong>建议优先使用该属性</strong>，而非分别设置三属性。默认值为 <code>0 1 auto</code>。<br>即，项目尺寸原本宽高，不放大，空间不够时按比例缩小。</p><p>常见设定：</p><ol><li><p><code>flex: auto</code> → <code>flex: 1 1 auto</code></p></li><li><p><code>flex: none</code> → <code>flex: 0 0 auto</code></p></li><li><p><code>flex: n</code> → <code>flex: n 1 0%</code><br>n为非负数字</p></li><li><p><code>flex: k</code> → <code>flex: 1 1 k</code><br>k为百分比%（相对于父容器而言）或长度px/em/vw/vh，注意 <code>0%</code> 是一个百分比而非一个非负数字</p></li><li><p><code>flex: x y</code> → <code>flex: x y 0%</code></p></li><li><p><code>flex: n k</code> → <code>flex: n 1 k</code></p></li></ol></li></ul><p><strong>综合以上特性说明 <code>flex-grow</code>、<code>flex-shrink</code> 的生效情况：</strong></p><ol><li><p>当项目默认宽度和小于容器宽度时，<code>flex-grow</code> 生效</p></li><li><p>当 <code>flex-wrap</code> 为 <code>wrap | wrap-reverse</code>，且项目默认宽度和大于容器宽度时，项目会换行，换行后每一行都可能有剩余空间，这时 <code>flex-grow</code> 生效；若当前行所有子项的 <code>flex-grow</code> 都为 0，则剩余空间保留，若当前行存在部分项目的 <code>flex-grow</code> 不为 0，则剩余空间会被这些项目占据</p></li><li><p>当 <code>flex-wrap</code> 为 <code>nowrap</code>，且项目宽度和超过容器宽度时，<code>flex-shrink</code> 生效。当该行所有项目的 <code>flex-shrink</code> 都为 0 时，将出现横向滚动条</p></li></ol><h2 id="flex-item-size-计算的相关扩展"><a href="#flex-item-size-计算的相关扩展" class="headerlink" title="flex-item-size 计算的相关扩展"></a>flex-item-size 计算的相关扩展</h2><p>为方便说明均以水平方向主轴为例：</p><ol><li><p>元素存在默认宽高</p><p>如果项目有默认固定宽高（如 <code>&lt;input&gt;</code> 标签），且设置了 <code>flex-basis</code>，那么它的宽度将默认固定宽作为下限，若 <code>flex-basis</code> 大于默认固定宽，以 <code>flex-basis</code> 为准，反之则以默认固定宽为准。因此若想要实现 <code>&lt;input&gt;</code> 宽度完全自适应，可以设置其 <code>width</code> 为 0。</p></li><li><p>元素存在 <code>min-width</code> 或 <code>max-width</code></p><p>类似的，<code>min-width</code> 值作为下限，若 <code>flex-basis &gt; min-width</code>，项目宽度以 <code>flex-basis</code> 为准；若 <code>flex-basis &lt; min-width</code>，项目宽度以 <code>min-width</code> 为准。如果 <code>min-width</code> 超出容器范围，那么即使设置了 <code>flex-shrink</code> 也不会对其进行压缩。</p><p>反之，如果有 <code>max-width</code> 的限制，那么 <code>flex-basis</code> 无法超过这个值，在 <code>flex-grow</code> 生效情况下也至多只会扩大到 <code>max-width</code> 上限。</p></li><li><p><code>width: auto</code></p><p>前面提到，如果项目同时设定了 <code>width</code> 和 <code>flex-basis</code>，<code>flex-basis</code> 的优先度高可直接覆盖 <code>width</code> ，这是通常情况，如下图：</p><p><img src="https://i.loli.net/2018/06/02/5b129f09d92bc.png" alt="sample"></p><p>但当设定了 <code>width: auto;</code> 时，需分情况讨论：</p><p>项目中存在内容，且内容撑开的宽度大于容器宽度，则实际宽度以内容确定，且无法坍缩，此时 <code>flex-basis</code> 无效；若内容撑开的宽度小于容器宽度，则项目实际宽度由内容与 <code>flex-basis</code> 中的较大值确定：</p><p><img src="https://i.loli.net/2018/06/02/5b129dec574ce.png" alt="flex-basis01"></p><p>上下两张图的区别在于，内容撑开宽度分别大于和小于 <code>flex-basis</code>，但项目均未坍缩。</p><p><img src="https://i.loli.net/2018/06/02/5b129e45b5b01.png" alt="flex-basis02"></p><p>此外 <code>overflow: hidden</code> 也会对项目实际宽度有所影响，如下图，文字长度被限制在容器内，小于 <code>flex-basis</code>，项目可坍缩。</p><p><img src="https://i.loli.net/2018/06/02/5b129767833f7.png" alt="overflow: hidden"></p></li><li><p><code>max-width</code> 限定下的 <code>flex-grow</code></p><p>直接上图：</p><p><img src="https://i.loli.net/2018/06/02/5b129f7b18cef.png" alt="max-width/flex-grow"></p></li><li><p><code>min-width</code> 限定下的 <code>flex-shrink</code></p><p>直接上图：</p><p><img src="https://i.loli.net/2018/06/02/5b129f8b6dc83.png" alt="min-width/flex-shrink"></p></li><li><p>隐藏属性对 items-size 的影响</p><p>设置 <code>visibility: hidden; | visibility: collapse; | transform: scale;</code>项目宽度仍会被算进主轴，flex 有效；设置 <code>display: none;</code>，flex 失效。</p></li><li><p>绝对定位与 flex</p><p>由于脱离文档流，绝对定位元素不参与 flex 布局，即 flexbox 下设置 了绝对定位的项目会直接覆盖 flex 原有布局，唯一特例是当绝对定位的 <code>top/bottom/left/right</code> 属性值未设定，现以图例说明此特殊项目的位置（当然都已经设置了绝对定位为啥不写具体呢，不存在的……所以只是为了理解绝对定位与 flex 的相互作用）：</p><p>容器宽度 600px，高度 400px，所有项目均有外边距 20px。项目1， 2， 3， 4 按绝对定位确定位置；项目6， 7， 8， 9 按 flex 布局确定位置；项目 5 位置则同时受到绝对定位和 flex 布局影响。</p><p><img src="https://i.loli.net/2018/06/02/5b1298f9dc72f.png" alt="absolute/flex01"></p><p><img src="https://i.loli.net/2018/06/02/5b12991aba644.png" alt="absolute/flex02"></p><p><img src="https://i.loli.net/2018/06/02/5b12992b30b7f.png" alt="absolute/flex03"></p><p><img src="https://i.loli.net/2018/06/02/5b12994364ebb.png" alt="absolute/flex04"></p><p><img src="https://i.loli.net/2018/06/02/5b12993677010.png" alt="absolute/flex05"></p><p><img src="https://i.loli.net/2018/06/02/5b1299adea183.png" alt="absolute/flex06"></p></li></ol><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>PC端及移动端：<a href="https://caniuse.com/#search=flex" rel="external nofollow noopener noreferrer" target="_blank">CanIUse</a></p><p>IE10用的是旧版语法，IE11 bug也不少，PC端目前请谨慎使用。移动端建议把旧语法都加上……微信目前已完全支持。</p><p>前缀补全请用插件：autoprefixer</p><p>在gulp中使用 <a href="https://www.npmjs.com/package/gulp-autoprefixer" rel="external nofollow noopener noreferrer" target="_blank">gulp-autoprefixer</a></p><p>还有几个常见的坑：</p><ul><li><p>旧版规范中，使用比例伸缩布局时，不同项目的内容长短不同会导致无法均分，这时我们需要给项目设置 <code>width:0%</code></p></li><li><p>不要给项目设置 <code>margin:auto</code> 的属性，在部分安卓机下会导致该元素宽度撑开到 100% 占位</p></li><li><p><code>text-overflow: ellipsis;</code> 在 <code>display：flex</code> 元素上无效</p></li></ul><p>更多兼容性问题可查看：<a href="https://github.com/philipwalton/flexbugs" rel="external nofollow noopener noreferrer" target="_blank">flexbugs</a></p><p>参考资料及扩展阅读：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes" rel="external nofollow noopener noreferrer" target="_blank">使用 CSS 弹性盒子</a></p>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
            <tag> layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片懒加载（lazyload）的简单实现</title>
      <link href="/posts/4bdcf2eb/"/>
      <url>/posts/4bdcf2eb/</url>
      
        <content type="html"><![CDATA[<p>针对图片类网站或展示图片过多的部分页面，为减轻服务器压力、提高加载速度、优化用户体验，我们需对暂未出现在可视区域内的图片先不做加载，之后侦听滚动事件，待图片滚至可视区域再加载。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>将img的src指向默认loading（推荐）或干脆不设置，同时令<code>data-src</code>（命名可自定义）指向实际src，从而实现动态加载图片的机制。</p><a id="more"></a><h3 id="视口的宽高与滚动高度"><a href="#视口的宽高与滚动高度" class="headerlink" title="视口的宽高与滚动高度"></a>视口的宽高与滚动高度</h3><p>在写代码之前，先对几个容易混淆的知识点稍作介绍：</p><p><img src="https://i.loli.net/2018/05/19/5aff07e271200.png" alt="viewport.png"></p><ol><li>屏幕视口大小（图中1、2）<ul><li>原生：<br><code>window.innerHeight</code> 标准浏览器及IE9+<br><code>document.documentElement.clientHeight</code> 标准浏览器及低版本IE标准模式<br><code>document.body.clientHeight</code> 低版本混杂模式<br>PS：事实上后两种方式获取的高度与<code>window.innerHeight</code>有所不同，这3个属性的值逐个减小：<br><code>window.innerHeight</code> 包括整个DOM：内容、边框以及滚动条。<br><code>documentElement.clientHeight</code> 不包括整个文档的滚动条，但包括 html 的边框。<br><code>body.clientHeight</code> 除不包括 html 边框外，还不包括 body 的边框和滚动条。</li><li>jQuery：<br><code>$(window).height();</code></li></ul></li></ol><ol start="2"><li>滚动条滚动距离（图中3、4）<ul><li>原生：<br><code>window.pageYOffset</code> IE9+及标准浏览器<br><code>document.documentElement.scrollTop</code> 兼容ie低版本的标准模式<br><code>document.body.scrollTop</code> 兼容混杂模式</li><li>jQuery：<br><code>$(document).scrollTop();</code></li></ul></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="keyword">class</span>=<span class="string">"lazyload"</span> <span class="class"><span class="keyword">data</span>-src=url"&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>略过，注意图片需设置宽高。</p><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//立即执行函数</span></span><br><span class="line">        <span class="keyword">let</span> imgList = [], <span class="comment">// 页面所有img元素数组</span></span><br><span class="line">            delay, <span class="comment">// setTimeout 对象</span></span><br><span class="line">            time = <span class="number">250</span>, <span class="comment">// 延迟载入时间</span></span><br><span class="line">            offset = <span class="number">0</span>, <span class="comment">// 设置图片距离视口多远则立即加载的偏移量</span></span><br><span class="line">            _selector; <span class="comment">// 默认为 `.lazyload`</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">_isShow</span>(<span class="params">el</span>) </span>&#123; <span class="comment">//判断img是否已进入视口</span></span><br><span class="line">            <span class="keyword">let</span> coords = el.getBoundingClientRect();</span><br><span class="line">            <span class="keyword">return</span> ((coords.top &gt;= <span class="number">0</span> &amp;&amp; coords.left &gt;= <span class="number">0</span> &amp;&amp; coords.top) &lt;= (<span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight) + <span class="built_in">parseInt</span>(offset));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">_load</span>(<span class="params"></span>) </span>&#123; <span class="comment">//img加载</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = imgList.length; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_isShow(imgList[i])) &#123;</span><br><span class="line">                    imgList[i].src = imgList[i].getAttribute(<span class="string">'data-src'</span>);</span><br><span class="line">                    imgList.splice(i, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">_delay</span>(<span class="params"></span>) </span>&#123; <span class="comment">//函数节流</span></span><br><span class="line">            clearTimeout(delay);</span><br><span class="line">            delay = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                _load();</span><br><span class="line">            &#125;, time);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">lazyLoad</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">            _selector = selector || <span class="string">'.lazyload'</span>;</span><br><span class="line">            <span class="keyword">let</span> nodes = <span class="built_in">document</span>.querySelectorAll(selector);</span><br><span class="line">            imgList = <span class="built_in">Array</span>.apply(<span class="literal">null</span>, nodes);</span><br><span class="line">            _delay(); <span class="comment">//避免首次加载未触发scroll事件,主动触发一次加载函数</span></span><br><span class="line">            <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, _delay, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lazyLoad(<span class="string">'.lazyload'</span>);</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="步骤说明"><a href="#步骤说明" class="headerlink" title="步骤说明"></a>步骤说明</h3><ol><li><p>判断图片是否进入视口_isShow</p><p>通过调用<code>getBoundingClientRect()</code>方法，获得一组包含元素用于描述其边框相对于视口左部及顶部位置的只读属性——left、top、right与bottom，再与浏览器视口宽高对比即可判断元素是否已进入视口，offset为自定义偏差值，按实际需求确定。</p><p><code>top</code>：元素上边框与浏览器视口顶部间距<br><code>left</code>：元素左边框与浏览器视口左侧间距<br><code>right</code>：元素右边框与浏览器视口左侧间距<br><code>bottom</code>：元素底边框与浏览器视口顶部间距</p></li><li><p>图片加载_load</p><p>循环输出每个imgList中保存的图片对象，由<code>_isShow</code>函数判断是否需要加载图片，需要则立即从img的<code>data-src</code>属性中取得链接并赋值给src.完成上述动作后，<code>splice()</code>方法从数组中剔除该img对象引用，避免下次循环重复判断。</p></li><li><p>声明节流函数_delay</p><p>在类似<code>scroll</code>、<code>resize</code>事件中执行大量DOM操作或计算时，函数会被高频触发，导致性能下降，影响用户体验。<br>原理：每次执行<code>_delay</code>函数前先清除上一次<code>setTimeout</code>生成的引用，阻止上一次的函数调用（如果尚未执行），然后创建一个新的setTimeout，在time保存的时间间隔后调用函数。</p></li><li><p>侦听scroll事件，执行节流函数</p><p>使用<code>document.querySelectorAll()</code>方法获取需要实现懒加载的图片列表。<br>注意这里得到的只是一个nodeList，需要用<code>Array.apply</code>将nodes转变成一个数组保存至imgList中。</p></li></ol><p>至此，图片懒加载功能初步完成。</p>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lazyLoad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git指南</title>
      <link href="/posts/93ecec/"/>
      <url>/posts/93ecec/</url>
      
        <content type="html"><![CDATA[<p><a href="https://git-for-windows.github.io/" rel="external nofollow noopener noreferrer" target="_blank">官网</a></p><p><code>git --version</code> 查看版本</p><p>git初始设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name = <span class="string">"name"</span></span><br><span class="line">git config --global user.email = <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>git工作流程：</p><ol><li>工作区</li><li><code>git add</code> -&gt; 版本库stage暂存区</li><li><code>git commit</code> -&gt; 版本库master分支（以及指向master的HEAD指针）</li><li><code>git push</code> -&gt; 远程仓库</li></ol><p><code>git config --global --list</code> 查看全局参数</p><a id="more"></a><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p><code>git init</code> 仓库初始化</p><p>添加文件至仓库版本库分两步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add --all   //将所有更改的文件一次性添加至暂存区</span><br><span class="line">git add filename // 或指定添加单个file</span><br><span class="line">git commit -m <span class="string">"message"</span>  //将暂存区内容提交到当前分支，注明更改信息</span><br></pre></td></tr></table></figure><p><code>git status</code> 查看文件状态</p><p><code>git diff</code> 查看文件修改前后差异</p><!--more--><h3 id="版本管理（撤销、删除、回退）"><a href="#版本管理（撤销、删除、回退）" class="headerlink" title="版本管理（撤销、删除、回退）"></a>版本管理（撤销、删除、回退）</h3><p><code>git log</code> 查看最近的提交日志</p><p><code>git log --pretty=oneline</code> 单行显示提交日志</p><p><strong>撤销文件修改（尚未 <code>git commit</code>）分两种情况：</strong></p><ol><li>尚未使用 <code>git add</code> 命令添加到暂存区，直接撤销工作区中的修改：</li></ol><p><code>git checkout -- filename</code></p><ol start="2"><li>部分代码已添加至暂存区后又做了修改，若希望全部撤销：</li></ol><p><code>git reset HEAD filename</code> 先回到暂存区的版本，之后再 <code>git checkout -- filename</code></p><p><strong>删除文件</strong></p><p>本地文件手动删除，如果确认删除先 <code>git rm filename</code> 确认无误后 commit</p><p>若是误删需恢复，则 <code>git checkout -- filename</code></p><p><strong>版本回退（已 <code>git commit</code> 但尚未 <code>git push</code>）</strong></p><p><code>git reset --hard commitID</code> 利用 <code>git log</code> 得到的commitID返回版本</p><p><code>git reflog</code> 查看历史版本及指针，内容太多翻不完按’q’退出</p><h3 id="GitHub远程仓库"><a href="#GitHub远程仓库" class="headerlink" title="GitHub远程仓库"></a>GitHub远程仓库</h3><p>生成ssh key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><p>登陆Github，填入id_rsa.pub里的内容后，测试是否可以连接上GitHub。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>创建远程仓库，然后本地关联：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:user-name/repo-name.git   //关联远程repo</span><br><span class="line">git push -u origin master   //本地首次推送，实际上是把当前分支master推送到远程</span><br><span class="line">git push orgin master   //之后推送</span><br></pre></td></tr></table></figure><p>将远程仓库clone至本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:user-name/repo-name.git</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>HEAD指向当前分支，当前分支指向提交。</p><p><code>git branch &lt;name&gt;</code> 创建分支</p><p><code>git checkout &lt;name&gt;</code> 切换分支</p><p><code>git checkout -b &lt;name&gt;</code> 创建+切换分支</p><p><code>git branch -d &lt;name&gt;</code> 删除分支</p><p><code>git branch -D &lt;name&gt;</code> 强行删除分支，用于无需合并直接删除的情况。</p><p><code>git branch</code> 查看所有分支，当前分支前以 <code>*</code> 标注</p><p><code>git merge --no-ff -m &quot;merge with no-ff blalala&quot; &lt;name&gt;</code><br>普通模式（与fast-forward/recursive模式区分）：主要是为保留分支的相关信息，创建一个新的commitID，能看出曾经做过合并</p><p><code>git log --graph --pretty=oneline --abbrev-commit</code> 查看分支合并图</p><p>git最佳实践，master为主分支，用来做正式发布版之后的保留历史，其他分支包括dev用来做正常开发，多个feature用来做某些特性功能，release用来做发布版历史，每次发布都是用release打包，hotfix用来做发布版之后的一些及时迭代修复bug的工作。</p><p><code>git stash</code> 保存工作区现场，以便之后可恢复现场继续工作。用于处理紧急 bug，注意请先确保将开发分支的所有文件 git add 至暂存区，若直接切换分支会导致将开发分支的文件带入其他分支。</p><p><code>git stash list</code> 查看保存的工作现场</p><p><code>git stash pop</code> 恢复同时直接删除stash内容</p><p><code>git stash apply stash@{num}</code> 用于当保存多份 stash 时，恢复指定工作现场。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>master、dev分支，要时刻与远程同步；bug分支只用于在本地修复bug，无需推送到远程；<br>feature新功能分支是否推送取决于你是否和其他人合作在上面开发。</p><p><code>git remote -v</code> 查看远程库详细信息。</p><p><strong>多人协作通常工作模式</strong></p><p>从远程库clone，默认只看到本地的master分支，要在dev分支上操作需要创建远程origin的dev分支到本地：<code>git checkout -b dev origin/dev</code>，之后再本地dev上修改并push到远程即可。<br>考虑到项目发起人也会push内容：</p><ol><li><p><code>git push origin &lt;name&gt;</code> 试图推送自己的修改</p></li><li><p>如果推送失败，说明远程分支与本地试图推送的内容有冲突，需要先用<code>git pull</code>试图抓取远程的新提交</p></li><li><p>若<code>git pull</code>提示<code>There is no tracking information for the current branch.</code>则说明本地分支和远程分支的链接关系没有创建，解决方法：<br><code>git branch --track origin/dev dev</code></p></li><li><p>git pull 成功，解决冲突后，再次commit、push</p></li></ol><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p><code>git tag v1.0</code> 给当前分支打标签(自定义)，默认标签打在最新提交的commit上</p><p><code>git tag</code> 查看所有标签，按字母排序。</p><p>补打遗漏版本标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br><span class="line">git tag v0.9 commitID</span><br></pre></td></tr></table></figure><p><code>git show v1.0</code> 查看标签信息。</p><p><code>git tag -a v1.0 -m &quot;version 1.0 released&quot;</code> 创建带有说明的标签。</p><p><code>git tag -s v1.0 -m &quot;version &lt;name&gt; released&quot;</code> PGP签名标签。</p><p><code>git tag -d v1.0</code> 删除本地标签。</p><p><code>git push origin v1.0</code> 推送指定标签到远程</p><p><code>git push origin --tags</code> 推送标签到远程</p><p>若标签已推送到远程现需删除，分两步，首先本地删除，之后执行：<br><code>git push origin :refs/tags/v0.9</code> 查看远程标签状态点击releases栏</p><h3 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h3><p><code>.gitignore</code> 编辑要忽略的文件，并提交到Git中，就可忽略特殊文件的检查。<br>如将 <code>*.db</code> 写入 <code>.gitignore</code> 文件中，将忽略所有db文件。</p><p><a href="https://github.com/github/gitignore" rel="external nofollow noopener noreferrer" target="_blank">github收集的各种.gitignore</a><br><br></p><p><strong><em>参考资料</em></strong></p><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="external nofollow noopener noreferrer" target="_blank">廖雪峰的Git教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
